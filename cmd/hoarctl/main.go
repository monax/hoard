package main

import (
	"context"
	"net"
	"os"

	"github.com/monax/hoard/v8/api"

	cli "github.com/jawher/mow.cli"
	"github.com/monax/hoard/v8/cmd"
	"github.com/monax/hoard/v8/config"
	"github.com/monax/hoard/v8/server"
	"google.golang.org/grpc"
)

const (
	addrOpt string = "The address of the data to retrieve as base64-encoded string."
	keyOpt  string = "The ID of the symmetric secret to use."
	saltOpt string = "Token to use for encryption and decryption. " +
		"Will be parsed as base64 encoded string if this is possible, " +
		"otherwise will be interpreted as the bytes of the string itself."
	secretOpt string = "The secret key to decrypt the data with as base64-encoded string."
	chunkOpt  string = "Size in bytes to chunk upload data at."
	fileOpt   string = "File to read"

	chunkSize = 64 * 1024 // 64 Kb
)

// Client scopes the available hoard clients
type Client struct {
	cleartext  api.CleartextClient
	encryption api.EncryptionClient
	grant      api.GrantClient
	storage    api.StorageClient
}

func main() {
	hoarctlApp := cli.App("hoarctl",
		"Command line interface to the hoard daemon a content-addressed "+
			"deterministically encrypted blob storage system")

	dialURL := hoarctlApp.StringOpt("a address", config.DefaultListenAddress,
		"local address on which hoard is listening encoded as a URL with the "+
			"network protocol as the scheme, for example 'tcp://localhost:54192' "+
			"or 'unix:///tmp/hoard.sock'")

	client := Client{}
	var conn *grpc.ClientConn

	hoarctlApp.Before = func() {
		netProtocol, localAddress, err := server.SplitListenURL(*dialURL)

		conn, err = grpc.Dial(*dialURL,
			grpc.WithInsecure(),
			// We have to bugger around with this so we can dial an arbitrary net.Conn
			grpc.WithContextDialer(func(context.Context, string) (net.Conn, error) {
				return net.Dial(netProtocol, localAddress)
			}))
		if err != nil {
			fatalf("Could not dial hoard server on %s: %v", *dialURL, err)
		}
		client.cleartext = api.NewCleartextClient(conn)
		client.encryption = api.NewEncryptionClient(conn)
		client.grant = api.NewGrantClient(conn)
		client.storage = api.NewStorageClient(conn)
	}

	cmd.AddVersionCommand(hoarctlApp)

	hoarctlApp.Command("put", "Put some data read from STDIN into encrypted data store and return a reference on STDOUT", client.Put)
	hoarctlApp.Command("delete", "Delete data located at the address fed from STDIN", client.Delete)
	hoarctlApp.Command("get", "Get some data from encrypted data store and write it to STDOUT - must have the JSON reference to the "+
		"object passed in on STDIN (as generated by ref or put) or the ADDRESS and SECRET_KEY provided", client.Get)
	hoarctlApp.Command("stat", "Get information about the encrypted blob stored as an address from a reference passed in on STDIN "+
		"or passed as in as a single argument as a base64 encoded string", client.Stat)
	hoarctlApp.Command("insert", "Insert data from STDIN directly into store at its address which is written to STDOUT", client.Insert)
	hoarctlApp.Command("cat", "Retrieve the encrypted blob stored as an address from a reference passed in on STDIN or passed as in as "+
		"a single argument as a base64 encoded string", client.Cat)

	hoarctlApp.Command("ref", "Encrypt data from STDIN and return its reference", client.Ref)
	hoarctlApp.Command("encrypt", "Encrypt data from STDIN and output encrypted data on STDOUT", client.Encrypt)
	hoarctlApp.Command("decrypt", "Decrypt data from STDIN and output decrypted data on STDOUT", client.Decrypt)

	hoarctlApp.Command("seal", "Seal some data read from STDIN and return grant on STDOUT", client.Seal)
	hoarctlApp.Command("unseal", "Unseal grant read from STDIN and print data to STDOUT", client.Unseal)
	hoarctlApp.Command("reseal", "Reseal grant read from STDIN and print new grant to STDOUT", client.Reseal)
	hoarctlApp.Command("putseal", "Put some data read from STDIN into encrypted data store and return a grant on STDOUT", client.PutSeal)
	hoarctlApp.Command("unsealget", "Unseal grant read from STDIN and print decrypted data to STDOUT", client.UnsealGet)

	hoarctlApp.Run(os.Args)
}
